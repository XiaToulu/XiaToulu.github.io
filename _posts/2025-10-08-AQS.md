---
layout: default
title: AQS
---

### 1. 什么是AQS？

**AQS**，全称 **AbstractQueuedSynchronizer**（抽象队列同步器），是 `java.util.concurrent.locks` 包下的一个核心基础组件。

你可以把它理解成一个 **构建锁和同步器（如 Semaphore, CountDownLatch 等）的“框架”**。JDK中许多知名的同步工具，其内部实现都依赖于AQS，例如：

*   `ReentrantLock`
*   `ReentrantReadWriteLock`
*   `Semaphore`
*   `CountDownLatch`
*   `ThreadPoolExecutor` 中的 Worker

**AQS的核心思想：**

如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，同时将共享资源设置为锁定状态。

如果被请求的共享资源被占用，AQS会通过一个 **阻塞队列** 来管理这些获取资源失败的线程。它将那些暂时获取不到锁的线程放入一个队列中，并在资源被释放时，按照一定的规则（如FIFO）唤醒队列中的线程，使其重新尝试获取资源。

**AQS的核心功能：**

1.  **同步状态的管理**：通过一个 volatile 的整型变量 `state` 来代表共享资源的状态。
2.  **阻塞线程的排队**：通过一个 **FIFO的CLH队列** 来管理那些未能获取到资源的线程。
3.  **线程的阻塞与唤醒**：通过调用 `LockSupport.park()` 和 `LockSupport.unpark(thread)` 来实现。

---

### 2. 底层是如何实现的？

AQS的实现可以概括为三大核心要素：**同步状态（state）**、**CLH队列** 和 **模板方法模式**。

#### 核心要素一：同步状态（State）

*   AQS内部维护了一个用 `volatile` 修饰的整型变量 `state`。
*   **`state` 的具体含义由子类（即具体的锁）来决定**，这是AQS灵活性的关键。
    *   在 `ReentrantLock` 中，`state` 表示锁被重入的次数。`state=0` 表示锁空闲，`state=1` 表示锁被占用，`state>1` 表示被同一个线程重入。
    *   在 `Semaphore` 中，`state` 表示剩余的许可证数量。
    *   在 `CountDownLatch` 中，`state` 表示倒计数的初始值。

所有对资源的获取和释放操作，本质上都是通过对 `state` 这个变量进行 **原子性的 CAS（Compare-And-Swap）操作** 来完成的。

#### 核心要素二：CLH队列（线程阻塞队列）

CLH队列是一个虚拟的FIFO双向队列。它并不是真实存在的队列实例，而是通过节点（`Node`）之间的前后指针关联起来的。

*   **节点（Node）**：AQS定义了一个内部类 `Node`，每个等待获取资源的线程都会被封装成一个 `Node` 节点。
*   **队列结构**：这个队列有一个头节点（`head`）和一个尾节点（`tail`）。头节点不关联任何线程，可以理解为当前正持有锁的线程节点。
*   **工作流程**：
    1.  当一个线程尝试获取锁（即修改 `state`）失败时，AQS会将其构造为一个 `Node` 节点，并使用 **CAS操作** 将其安全地插入到队列的尾部。
    2.  插入队列的线程会检查其前驱节点是否为头节点，如果是，则会再次尝试获取锁。如果不是，或者获取失败，则会进入阻塞状态（通过 `LockSupport.park(this)`），等待被唤醒。
    3.  当持有锁的线程释放资源时，它会唤醒队列中头节点的下一个节点（如果存在）。被唤醒的线程会再次尝试获取锁。

#### 核心要素三：模板方法模式

AQS是一个抽象类，它使用了 **模板方法模式**。它定义了获取和释放资源的整体骨架流程（主要是入队、出队、阻塞、唤醒），而将一些关键步骤的实现留给子类。

**需要子类重写的方法（protected）：**

*   `tryAcquire(int arg)`：尝试以独占方式获取资源。成功返回true，失败返回false。
*   `tryRelease(int arg)`：尝试以独占方式释放资源。成功返回true，失败返回false。
*   `tryAcquireShared(int arg)`：尝试以共享方式获取资源。负数表示失败；0表示成功，但无剩余资源；正数表示成功，且有剩余资源。
*   `tryReleaseShared(int arg)`：尝试以共享方式释放资源。

**AQS提供给外部的核心方法（public final）：**

*   `acquire(int arg)`：以独占方式获取资源。如果获取失败，会将线程加入队列，并可能阻塞。
*   `release(int arg)`：以独占方式释放资源。
*   `acquireShared(int arg)`：以共享方式获取资源。
*   `releaseShared(int arg)`：以共享方式释放资源。

**模板方法的工作流程（以 `acquire` 为例）：**

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) && // 步骤1：子类尝试直接获取锁
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 步骤2&3：获取失败，则加入队列并可能阻塞
        selfInterrupt(); // 如果在阻塞过程中被中断，补上中断标记
}
```

1.  **`tryAcquire(arg)`**：首先调用子类重写的方法，尝试直接获取锁。如果成功，整个流程结束。
2.  **`addWaiter(Node.EXCLUSIVE)`**：如果 `tryAcquire` 失败，则调用此方法，将当前线程包装成一个独占模式的Node节点，并通过CAS操作将其添加到CLH队列的末尾。
3.  **`acquireQueued(final Node node, int arg)`**：让队列中的节点循环尝试获取锁。在循环中，它会检查当前节点的前驱节点是不是头节点：
    *   如果是，则再次调用 `tryAcquire` 尝试获取锁。
    *   如果获取成功，则将当前节点设置为新的头节点，原头节点出队。
    *   如果不是头节点，或者获取再次失败，则会判断是否应该将当前线程阻塞（`shouldParkAfterFailedAcquire`）。如果需要，则调用 `LockSupport.park(this)` 阻塞当前线程。
    *   当线程被前驱节点唤醒时（`unpark`），它会继续在循环中尝试获取锁。

---

### 总结

**AQS的本质是一个用于构建锁和同步器的框架。它通过一个 `state` 变量来标识资源状态，通过一个FIFO队列来管理未获取到资源的线程，并通过模板方法模式，将资源获取与释放的具体逻辑交由子类实现。**

**其底层实现的精髓在于：**

*   **状态原子控制**：使用 `volatile` 和 **CAS** 操作来保证 `state` 变量的线程安全。
*   **队列精细管理**：通过CLH队列公平、高效地管理等待线程。
*   **线程精准阻塞与唤醒**：利用 `LockSupport` 实现对特定线程的阻塞和唤醒。
*   **设计模式的应用**：模板方法模式使得AQS作为一个基础骨架，具有极高的扩展性。

理解了AQS，就理解了JDK中大部分并发工具类的底层工作原理，是深入学习Java并发的关键一步。