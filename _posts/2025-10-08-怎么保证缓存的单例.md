## 1. 经典单例模式实现（基础版）

### 饿汉式 - 线程安全，类加载时就初始化
```java
public class CacheManager {
    // 类加载时就创建实例，保证线程安全
    private static final CacheManager INSTANCE = new CacheManager();
    private final Map<String, Object> cache;
    
    private CacheManager() {
        this.cache = new ConcurrentHashMap<>();
        // 初始化缓存配置
    }
    
    public static CacheManager getInstance() {
        return INSTANCE;
    }
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        return cache.get(key);
    }
}
```

### 懒汉式 - 双重检查锁（DCL）
```java
public class CacheManager {
    private static volatile CacheManager instance;
    private final Map<String, Object> cache;
    
    private CacheManager() {
        this.cache = new ConcurrentHashMap<>();
    }
    
    public static CacheManager getInstance() {
        if (instance == null) {
            synchronized (CacheManager.class) {
                if (instance == null) {
                    instance = new CacheManager();
                }
            }
        }
        return instance;
    }
    
    // 缓存操作方法...
}
```

### 静态内部类方式 - 推荐使用
```java
public class CacheManager {
    private final Map<String, Object> cache;
    
    private CacheManager() {
        this.cache = new ConcurrentHashMap<>();
    }
    
    // 静态内部类在第一次被引用时才会加载，实现了懒加载且线程安全
    private static class Holder {
        private static final CacheManager INSTANCE = new CacheManager();
    }
    
    public static CacheManager getInstance() {
        return Holder.INSTANCE;
    }
}
```

## 2. 枚举方式实现 - 《Effective Java》推荐

```java
public enum CacheManager {
    INSTANCE;
    
    private final Map<String, Object> cache;
    
    CacheManager() {
        this.cache = new ConcurrentHashMap<>();
        // 初始化操作
    }
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        return cache.get(key);
    }
    
    // 使用方式：CacheManager.INSTANCE.put("key", "value");
}
```

**优点**：线程安全，防止反射攻击，序列化安全。

## 3. 使用依赖注入框架（生产环境推荐）

### Spring Framework 中的单例缓存
```java
@Component // 默认就是单例
public class CacheService {
    
    private final Cache<String, Object> cache;
    
    @PostConstruct
    public void init() {
        this.cache = Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .maximumSize(1000)
                .build();
    }
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        return cache.getIfPresent(key);
    }
}

// 在其他类中通过依赖注入使用
@Service
public class UserService {
    
    @Autowired
    private CacheService cacheService; // 注入的是单例实例
    
    public User getUserById(Long id) {
        String cacheKey = "user:" + id;
        User user = (User) cacheService.get(cacheKey);
        if (user == null) {
            user = userRepository.findById(id);
            cacheService.put(cacheKey, user);
        }
        return user;
    }
}
```

### Spring Cache 注解方式
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .maximumSize(1000));
        return cacheManager; // Spring会将其作为单例管理
    }
}

@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id")
    public User getUserById(Long id) {
        return userRepository.findById(id);
    }
}
```

## 4. 使用成熟的缓存框架

### 使用 Guava Cache
```java
public class GlobalCacheManager {
    private static GlobalCacheManager instance;
    private final LoadingCache<String, Object> cache;
    
    private GlobalCacheManager() {
        this.cache = CacheBuilder.newBuilder()
                .maximumSize(1000)
                .expireAfterWrite(10, TimeUnit.MINUTES)
                .build(new CacheLoader<String, Object>() {
                    @Override
                    public Object load(String key) {
                        return loadFromDataSource(key);
                    }
                });
    }
    
    public static synchronized GlobalCacheManager getInstance() {
        if (instance == null) {
            instance = new GlobalCacheManager();
        }
        return instance;
    }
}
```

### 使用 Redis 作为分布式缓存
```java
@Component
public class RedisCacheManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void set(String key, Object value, Duration timeout) {
        redisTemplate.opsForValue().set(key, value, timeout);
    }
    
    public Object get(String key) {
        return redisTemplate.opsForValue().get(key);
    }
    
    // Spring 会自动将 RedisTemplate 作为单例管理
}
```

## 5. 保证单例的关键要点

### 线程安全考虑
```java
public class ThreadSafeCache {
    // 使用线程安全的容器
    private final ConcurrentMap<String, Object> cache = new ConcurrentHashMap<>();
    
    // 或者使用 Collections.synchronizedMap
    // private final Map<String, Object> cache = 
    //     Collections.synchronizedMap(new HashMap<>());
}
```

### 防止反射攻击
```java
public class SafeSingletonCache {
    private static volatile SafeSingletonCache instance;
    
    private SafeSingletonCache() {
        // 防止通过反射创建实例
        if (instance != null) {
            throw new RuntimeException("Use getInstance() method to get the single instance of this class.");
        }
    }
}
```

### 防止序列化破坏单例
```java
public class SerializableCache implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private SerializableCache() {}
    
    private static class Holder {
        private static final SerializableCache INSTANCE = new SerializableCache();
    }
    
    public static SerializableCache getInstance() {
        return Holder.INSTANCE;
    }
    
    // 防止序列化破坏单例
    protected Object readResolve() {
        return getInstance();
    }
}
```

## 6. 现代微服务架构中的缓存单例

在微服务架构中，通常使用独立的缓存服务：

```java
@Configuration
public class CacheClientConfig {
    
    @Bean
    @Scope("singleton") // 明确指定单例作用域
    public CacheClient cacheClient() {
        // 连接Redis集群或Memcached集群
        return new RedisCacheClient("redis-cluster:6379");
    }
}
```

## 总结

保证缓存单例的最佳实践：

1. **小型项目**：使用枚举或静态内部类方式
2. **Spring项目**：使用`@Component` + 依赖注入，让Spring容器管理单例
3. **生产环境**：结合Spring Cache和成熟的缓存框架（Caffeine、Redis）
4. **分布式系统**：使用Redis等分布式缓存，在客户端保证连接池的单例

**核心原则**：无论采用哪种方式，关键是要确保在整个应用生命周期中，缓存的管理器实例只有一个，这样才能保证缓存数据的一致性和性能优化。