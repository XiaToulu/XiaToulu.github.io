### 大 Key 问题

#### 1. 什么是大 Key？

通常指：
- **String 类型**：Value > 10KB
- **集合类型**（Hash, List, Set, ZSet）：元素数量 > 1000 或 Value 总大小 > 10MB
- **Stream**：长度过长或总大小过大

#### 2. 大 Key 的危害

**a) 阻塞请求**
- Redis 是单线程的，操作大 Key 耗时较长（如 `hgetall` 一个包含 10 万字段的 Hash），会阻塞后续所有命令。
- `DEL` 一个大 Key 可能造成 Redis 数秒甚至更长时间的阻塞。

**b) 网络拥塞**
- 一次返回大 Key 的数据会占用大量带宽，增加网络传输时间。
- 在集群模式下，跨节点迁移包含大 Key 的槽位时，网络开销巨大。

**c) 内存不均**
- 在集群模式下，大 Key 会导致某个节点的内存使用率远高于其他节点，破坏负载均衡。
- 可能引发内存溢出（OOM），导致服务崩溃。

**d) 持久化问题**
- 生成 RDB 快照时，`fork()` 进程需要复制父进程的内存页表。如果内存占用过大，`fork()` 操作会变慢，导致主进程短暂阻塞。

---

### 热 Key 问题

#### 1. 什么是热 Key？

某个 Key 的**访问频率**远高于其他 Key，通常有大量的并发读或写请求集中在一个 Key 上。

#### 2. 热 Key 的危害

**a) 性能瓶颈**
- 所有对热 Key 的请求都会落到同一个 Redis 节点（在集群模式下）或同一个 CPU 核心上。
- 由于 Redis 单线程处理模型，容易达到该节点的性能上限，造成延迟飙升。

**b) 单点故障**
- 如果该热 Key 所在的节点宕机，即使有从节点，大量突发请求也可能在故障转移期间冲垮新主节点。

**c) 数据倾斜**
- 在集群中，某个节点因承载热 Key 而负载过高，而其他节点相对空闲。

---

### 排查方法

#### 1. 大 Key 排查

**a) 内置命令**
```bash
# Redis 4.0+ 提供了内存分析工具
redis-cli --bigkeys

# 示例输出，会扫描所有数据库并找出每种类型中最大的key
# Biggest string found so far 'big_string' with 10240 bytes
# Biggest hash   found so far 'big_hash' with 100000 fields
```
*优点*：简单快捷。
*缺点*：`--bigkeys` 只能找到每种类型中最大的一个，可能漏掉很多其他大 Key；对线上服务有性能影响，应在低峰期执行。

**b) 使用 SCAN 命令编写脚本**
```python
import redis
r = redis.Redis()

def find_big_keys(threshold_kb=10, count=100):
    cursor = 0
    big_keys = []
    while True:
        cursor, keys = r.scan(cursor=cursor, count=count)
        for key in keys:
            memory = r.memory_usage(key)
            if memory and memory > threshold_kb * 1024:
                key_type = r.type(key).decode()
                big_keys.append((key, key_type, memory))
        if cursor == 0:
            break
    return big_keys
```

**c) 第三方工具**
- **Redis RDB Tools**：分析 RDB 文件，获取精确的内存统计，对线上服务无影响。
  ```bash
  rdb -c memory dump.rdb --bytes 10240 --type string
  ```

#### 2. 热 Key 排查

**a) Redis 5.0+ 的 `MONITOR` 命令（谨慎使用）**
```bash
# 在短时间内监控所有命令，然后分析命令频率
redis-cli monitor > commands.log
# 运行一段时间后 Ctrl+C，然后分析
awk '{print $5}' commands.log | sort | uniq -c | sort -nr
```
*警告*：`MONITOR` 对性能影响极大，只能在测试环境或线上紧急排查时短暂使用。

**b) Redis 6.2+ 的热点监控功能**
Redis 6.2 引入了 `redis-cli --hotkeys` 选项，基于 `LFU` 算法统计热点 Key。
```bash
redis-cli --hotkeys
# 需要确保配置了 maxmemory-policy 为 allkeys-lfu 或 volatile-lfu
```

**c) 客户端埋点**
在应用程序代码中统计 Key 的访问频率，这是最准确的方式。

**d) 网络流量分析**
通过监控网络流量，发现接收或发送数据异常高的节点或 Key。

---

### 解决方案

#### 1. 大 Key 解决方案

**a) 拆分**
- **String 大 Key**：拆分成多个子 Key，使用 `MGET` 批量获取。
- **Hash 大 Key**：按字段前缀拆分成多个 Hash。例如 `user:1000:profile` 拆成 `user:1000:base_info`、`user:1000:contact_info` 等。
- **List/Set/ZSet 大 Key**：按时间、范围或哈希分片拆分成多个 Key。

**b) 压缩**
- 如果 Value 是文本（如 JSON、XML），可在客户端进行压缩/解压缩。
- 使用更高效的序列化工具（如 Protocol Buffers、MessagePack）。

**c) 删除优化**
- 对于集合类型，使用 `UNLINK` 代替 `DEL`（异步删除，不阻塞）。
- 对于超大的 Key，使用渐进式删除：
  ```python
  # 渐进式删除大 Hash
  def delete_big_hash(key, batch_size=100):
      cursor = 0
      while True:
          cursor, fields = r.hscan(key, cursor, count=batch_size)
          if fields:
              r.hdel(key, *fields.keys())
          if cursor == 0:
              break
  ```

**d) 数据过期**
对不重要的大 Key 设置合理的 TTL，让其自动过期。

#### 2. 热 Key 解决方案

**a) 本地缓存（最有效）**
- 在应用层使用 Guava Cache、Caffeine 等本地缓存热 Key 数据。
- 设置合适的过期时间和缓存大小，防止本地内存溢出。
- 需要考虑缓存一致性问题（当 Redis 中数据更新时，如何失效本地缓存）。

**b) 备份 Key**
- 将热 Key 复制成多个备份 Key，如 `hot_key`、`hot_key_bak1`、`hot_key_bak2`。
- 客户端随机访问不同的备份 Key，将请求分散。
- 更新时需要同时更新所有备份。

**c) 使用 Redis Cluster 代理**
- 像 Twemproxy、Codis 这样的代理层可以在一定程度上帮助分散热 Key 的压力。

**d) 业务逻辑优化**
- 检查业务逻辑，看是否可以通过优化来避免产生热 Key。
- 例如，将频繁更新的计数器拆分成多个子计数器，定期汇总。

---

### 架构师视角：预防为主

1. **设计阶段评审**
   - 在系统设计阶段就关注可能产生大 Key 和热 Key 的场景。
   - 制定 Key 命名规范和数据结构设计规范。

2. **监控告警**
   ```bash
   # 监控关键指标
   - used_memory
   - instantaneous_ops_per_sec
   - network_input_bytes/sec
   - network_output_bytes/sec
   - latency
   ```
   - 设置大 Key 和热 Key 的自动检测和告警机制。

3. **容量规划**
   - 定期进行容量评估，提前识别潜在的大 Key 风险。
   - 对重要业务的数据增长建立预测模型。

4. **应急预案**
   - 准备完善的大 Key 和热 Key 应急处理流程。
   - 定期进行演练，确保团队熟悉处理流程。

### 总结

大 Key 和热 Key 是 Redis 使用过程中的"慢性病"和"急性病"：
- **大 Key** 像慢性病，长期消耗资源，最终导致系统崩溃。
- **热 Key** 像急性病，短时间内可能直接冲垮服务。

